import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';

export interface ReportMetadata {
  reportTitle: string;
  generatedBy: string;
  userEmail: string;
  tenantName: string;
  tenantId: string;
  generatedAt: Date;
  reportType: string;
  version: string;
}

export interface ProjectComparisonData {
  matchedCount: number;
  onlyInPipedriveCount: number;
  onlyInXeroCount: number;
  projectsOnlyInPipedrive: Array<{ name: string; key: string; id?: string; status?: string }>;
  projectsOnlyInXero: Array<{ name: string; key: string; id?: string; status?: string }>;
  matchedProjects?: Array<{ pipedriveProject: any; xeroProject: any; key: string }>;
  pipedriveDisabled?: boolean;
  pipedriveError?: string;
  rawPipedriveDeals?: any[];
  rawXeroProjects?: any[];
  valueDiscrepancies?: Array<{
    projectName: string;
    projectKey: string;
    pipedriveValue: number;
    xeroValue: number;
    difference: number;
    differencePercentage: number;
  }>;
}

export class ProfessionalReportGenerator {
  private static readonly COMPANY_NAME = "CustomXero";
  private static readonly REPORT_VERSION = "2.0";

  /**
   * Generates professional project comparison reports in multiple formats
   * @param {ProjectComparisonData} data - Project comparison data with matched/unmatched projects
   * @param {ReportMetadata} metadata - Report metadata including user info and timestamps
   * @param {'csv' | 'xlsx' | 'txt'} format - Output format (defaults to 'xlsx')
   * @returns {Promise<void>} Promise that resolves when report is generated and downloaded
   * @throws {Error} When unsupported format is specified
   */
  static async generateProjectComparisonReport(
    data: ProjectComparisonData,
    metadata: ReportMetadata,
    format: 'csv' | 'xlsx' | 'txt' = 'xlsx'
  ): Promise<void> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const fileName = `project-comparison-report-${timestamp}`;

    switch (format) {
      case 'xlsx':
        await this.generateExcelReport(data, metadata, fileName);
        break;
      case 'csv':
        await this.generateCSVReport(data, metadata, fileName);
        break;
      case 'txt':
        await this.generateTextReport(data, metadata, fileName);
        break;
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  private static async generateExcelReport(
    data: ProjectComparisonData,
    metadata: ReportMetadata,
    fileName: string
  ): Promise<void> {
    const workbook = XLSX.utils.book_new();

    // Executive Summary Sheet
    const summaryData = [
      [data.pipedriveDisabled ? 'Xero Projects Report' : 'Project Comparison Report'],
      [''],
      ['Report Information'],
      ['Company', this.COMPANY_NAME],
      ['Generated By', metadata.generatedBy],
      ['User Email', metadata.userEmail],
      ['Organisation', metadata.tenantName],
      ['Tenant ID', metadata.tenantId],
      ['Generated On', metadata.generatedAt.toLocaleString()],
      ['Report Version', this.REPORT_VERSION],
      ['']
    ];

    if (data.pipedriveDisabled) {
      summaryData.push(
        ['Executive Summary'],
        ['Pipedrive Status', 'Disabled'],
        ['Total Xero Projects', data.onlyInXeroCount.toString()],
        ['Report Type', 'Xero Projects Analysis'],
        ['Pipedrive Note', data.pipedriveError || 'Integration disabled'],
        [''],
        ['Key Insights'],
        ['Data Source', 'Xero (Accounting) Only'],
        ['Analysis Type', 'Complete Xero projects inventory'],
        ['Last Updated', new Date().toLocaleString()]
      );
    } else {
      summaryData.push(
        ['Executive Summary'],
        ['Total Matched Projects', data.matchedCount.toString()],
        ['Projects Only in Pipedrive', data.onlyInPipedriveCount.toString()],
        ['Projects Only in Xero', data.onlyInXeroCount.toString()],
        ['Total Projects Analyzed', (data.matchedCount + data.onlyInPipedriveCount + data.onlyInXeroCount).toString()],
        [''],
        ['Sync Status'],
        ['Synchronization Level', this.getSyncStatus(data)],
        ['Action Required', data.onlyInPipedriveCount > 0 || data.onlyInXeroCount > 0 ? 'Yes' : 'No'],
        ['Value Discrepancies', (data.valueDiscrepancies?.length || 0).toString()],
        [''],
        ['Key Insights'],
        ['Data Source Comparison', 'Pipedrive (CRM) vs Xero (Accounting)'],
        ['Matching Logic', 'Enhanced multi-strategy matching: ED codes, project numbers, fuzzy name matching'],
        ['Match Quality', data.matchedCount > 0 ? 'Successful matches found' : 'No matches - review naming conventions'],
        ['Last Updated', new Date().toLocaleString()]
      );
    }

    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
    
    // Style the header
    if (!summarySheet['!merges']) summarySheet['!merges'] = [];
    summarySheet['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 1 } });
    
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Executive Summary');

    // Pipedrive Only Projects Sheet (skip if disabled)
    if (!data.pipedriveDisabled && data.projectsOnlyInPipedrive.length > 0) {
      const pipedriveData = [
        ['Projects Only in Pipedrive', '', '', ''],
        ['These projects exist in Pipedrive but not in Xero', '', '', ''],
        ['Action Required: Consider creating these projects in Xero', '', '', ''],
        [''],
        ['No.', 'Project Name', 'Matching Key', 'Status']
      ];

      data.projectsOnlyInPipedrive.forEach((project, index) => {
        pipedriveData.push([
          (index + 1).toString(),
          project.name,
          project.key,
          project.status || 'Unknown'
        ]);
      });

      const pipedriveSheet = XLSX.utils.aoa_to_sheet(pipedriveData);
      XLSX.utils.book_append_sheet(workbook, pipedriveSheet, 'Pipedrive Only');
    }

    // Xero Projects Sheet
    if (data.projectsOnlyInXero.length > 0) {
      let xeroData: string[][];
      
      if (data.pipedriveDisabled) {
        xeroData = [
          ['Xero Projects', '', '', ''],
          ['Complete list of projects in your Xero organization', '', '', ''],
          ['Pipedrive integration is disabled for this tenant', '', '', ''],
          [''],
          ['No.', 'Project Name', 'Matching Key', 'Status']
        ];
      } else {
        xeroData = [
          ['Projects Only in Xero', '', '', ''],
          ['These projects exist in Xero but not in Pipedrive', '', '', ''],
          ['Action Required: Consider reviewing project status in CRM', '', '', ''],
          [''],
          ['No.', 'Project Name', 'Matching Key', 'Status']
        ];
      }

      data.projectsOnlyInXero.forEach((project, index) => {
        xeroData.push([
          (index + 1).toString(),
          project.name,
          project.key,
          project.status || 'Unknown'
        ]);
      });

      const xeroSheet = XLSX.utils.aoa_to_sheet(xeroData);
      XLSX.utils.book_append_sheet(workbook, xeroSheet, data.pipedriveDisabled ? 'Xero Projects' : 'Xero Only');
    }

    // Matched Projects Sheet (if available)
    if (data.matchedProjects && data.matchedProjects.length > 0) {
      const matchedData = [
        ['Matched Projects', '', '', '', '', ''],
        ['These projects exist in both systems', '', '', '', '', ''],
        ['Status: Synchronized', '', '', '', '', ''],
        [''],
        ['No.', 'Matching Key', 'Pipedrive Name', 'Xero Name', 'Pipedrive ID', 'Xero ID']
      ];

      data.matchedProjects.forEach((match, index) => {
        matchedData.push([
          (index + 1).toString(),
          match.key,
          match.pipedriveProject?.name || 'N/A',
          match.xeroProject?.name || 'N/A',
          match.pipedriveProject?.id || 'N/A',
          match.xeroProject?.projectId || 'N/A'
        ]);
      });

      const matchedSheet = XLSX.utils.aoa_to_sheet(matchedData);
      XLSX.utils.book_append_sheet(workbook, matchedSheet, 'Matched Projects');
    }

    // Value Discrepancies Sheet (if available)
    if (data.valueDiscrepancies && data.valueDiscrepancies.length > 0) {
      const discrepanciesData = [
        ['Value Discrepancies Report', '', '', '', '', ''],
        ['Projects with financial differences between systems', '', '', '', '', ''],
        [''],
        ['Project Name', 'Matching Key', 'Pipedrive Value', 'Xero Value', 'Difference', 'Difference %']
      ];

      data.valueDiscrepancies.forEach((discrepancy) => {
        discrepanciesData.push([
          discrepancy.projectName,
          discrepancy.projectKey,
          discrepancy.pipedriveValue.toFixed(2),
          discrepancy.xeroValue.toFixed(2),
          discrepancy.difference.toFixed(2),
          `${discrepancy.differencePercentage.toFixed(1)}%`
        ]);
      });

      const discrepanciesSheet = XLSX.utils.aoa_to_sheet(discrepanciesData);
      XLSX.utils.book_append_sheet(workbook, discrepanciesSheet, 'Value Discrepancies');
    }

    // Raw Pipedrive Data Sheet
    if (data.rawPipedriveDeals && data.rawPipedriveDeals.length > 0) {
      const pipedriveRawData = [
        ['Raw Pipedrive Deals Data', '', '', '', '', '', ''],
        ['Complete export of won deals from Pipedrive', '', '', '', '', '', ''],
        [''],
        ['Deal ID', 'Title', 'Value', 'Currency', 'Won Time', 'Organization', 'Status']
      ];

      data.rawPipedriveDeals.forEach((deal) => {
        pipedriveRawData.push([
          deal.id || '',
          deal.title || '',
          deal.value || 0,
          deal.currency || 'USD',
          deal.won_time ? new Date(deal.won_time).toLocaleString() : '',
          deal.org_name || '',
          deal.status || ''
        ]);
      });

      const pipedriveRawSheet = XLSX.utils.aoa_to_sheet(pipedriveRawData);
      XLSX.utils.book_append_sheet(workbook, pipedriveRawSheet, 'Raw Pipedrive Data');
    }

    // Raw Xero Data Sheet
    if (data.rawXeroProjects && data.rawXeroProjects.length > 0) {
      const xeroRawData = [
        ['Raw Xero Projects Data', '', '', '', '', '', '', ''],
        ['Complete export of projects from Xero', '', '', '', '', '', '', ''],
        [''],
        ['Project ID', 'Name', 'Contact Name', 'Status', 'Start Date', 'Total Amount', 'Currency', 'Deadline']
      ];

      data.rawXeroProjects.forEach((project) => {
        xeroRawData.push([
          project.projectId || '',
          project.name || '',
          project.contactName || '',
          project.status || '',
          project.startDate ? new Date(project.startDate).toLocaleDateString() : '',
          project.totalAmount?.value || 0,
          project.totalAmount?.currency || 'USD',
          project.deadlineDate ? new Date(project.deadlineDate).toLocaleDateString() : 'N/A'
        ]);
      });

      const xeroRawSheet = XLSX.utils.aoa_to_sheet(xeroRawData);
      XLSX.utils.book_append_sheet(workbook, xeroRawSheet, 'Raw Xero Data');
    }

    // Summary Statistics Sheet
    const statsData = [
      ['Summary Statistics'],
      [''],
      ['Overall Metrics'],
      ['Metric', 'Value'],
      ['Total Projects in Pipedrive', data.onlyInPipedriveCount + data.matchedCount],
      ['Total Projects in Xero', data.onlyInXeroCount + data.matchedCount],
      ['Matched Projects', data.matchedCount],
      ['Unmatched in Pipedrive', data.onlyInPipedriveCount],
      ['Unmatched in Xero', data.onlyInXeroCount],
      ['Match Percentage', `${((data.matchedCount / (data.matchedCount + data.onlyInPipedriveCount + data.onlyInXeroCount)) * 100).toFixed(1)}%`],
      [''],
      ['Matching Analysis'],
      ['Projects with Exact Name Match', data.matchedCount],
      ['Projects Requiring Manual Review', data.onlyInPipedriveCount + data.onlyInXeroCount],
      ['Value Discrepancies Found', data.valueDiscrepancies?.length || 0],
      [''],
      ['Report Generation Details'],
      ['Generated At', metadata.generatedAt.toISOString()],
      ['Report Type', metadata.reportType],
      ['Version', metadata.version],
      ['Tenant', `${metadata.tenantName} (${metadata.tenantId})`],
      ['User', `${metadata.generatedBy} (${metadata.userEmail})`]
    ];

    const statsSheet = XLSX.utils.aoa_to_sheet(statsData);
    XLSX.utils.book_append_sheet(workbook, statsSheet, 'Statistics');

    // Generate and save the file
    const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    saveAs(blob, `${fileName}.xlsx`);
  }

  private static async generateCSVReport(
    data: ProjectComparisonData,
    metadata: ReportMetadata,
    fileName: string
  ): Promise<void> {
    let csvContent = '';
    
    // Header with metadata
    csvContent += `${this.COMPANY_NAME} - Project Comparison Report\n`;
    csvContent += `Generated By,${metadata.generatedBy}\n`;
    csvContent += `User Email,${metadata.userEmail}\n`;
    csvContent += `Organisation,${metadata.tenantName}\n`;
    csvContent += `Generated On,${metadata.generatedAt.toLocaleString()}\n`;
    csvContent += `\n`;
    
    // Summary
    csvContent += `Executive Summary\n`;
    
    if (data.pipedriveDisabled) {
      csvContent += `Pipedrive Status,Disabled\n`;
      csvContent += `Total Xero Projects,${data.onlyInXeroCount}\n`;
      csvContent += `Report Type,Xero Projects Analysis\n`;
      csvContent += `Pipedrive Note,"${data.pipedriveError || 'Integration disabled'}"\n`;
    } else {
      csvContent += `Matched Projects,${data.matchedCount}\n`;
      csvContent += `Pipedrive Only,${data.onlyInPipedriveCount}\n`;
      csvContent += `Xero Only,${data.onlyInXeroCount}\n`;
      csvContent += `Sync Status,${this.getSyncStatus(data)}\n`;
    }
    
    csvContent += `\n`;
    
    // Pipedrive only projects (skip if disabled)
    if (!data.pipedriveDisabled && data.projectsOnlyInPipedrive.length > 0) {
      csvContent += `Projects Only in Pipedrive\n`;
      csvContent += `No,Project Name,Matching Key\n`;
      data.projectsOnlyInPipedrive.forEach((project, index) => {
        csvContent += `${index + 1},"${project.name}","${project.key}"\n`;
      });
      csvContent += `\n`;
    }
    
    // Xero projects
    if (data.projectsOnlyInXero.length > 0) {
      if (data.pipedriveDisabled) {
        csvContent += `Xero Projects\n`;
      } else {
        csvContent += `Projects Only in Xero\n`;
      }
      csvContent += `No,Project Name,Matching Key\n`;
      data.projectsOnlyInXero.forEach((project, index) => {
        csvContent += `${index + 1},"${project.name}","${project.key}"\n`;
      });
    }

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    saveAs(blob, `${fileName}.csv`);
  }

  private static async generateTextReport(
    data: ProjectComparisonData,
    metadata: ReportMetadata,
    fileName: string
  ): Promise<void> {
    const divider = '═'.repeat(80);
    const subDivider = '─'.repeat(80);
    
    let reportContent = `${divider}\n`;
    reportContent += `${this.COMPANY_NAME.toUpperCase()} - PROJECT COMPARISON REPORT\n`;
    reportContent += `${divider}\n\n`;
    
    // Metadata section
    reportContent += `📊 REPORT INFORMATION\n`;
    reportContent += `${subDivider}\n`;
    reportContent += `Generated By    : ${metadata.generatedBy}\n`;
    reportContent += `User Email      : ${metadata.userEmail}\n`;
    reportContent += `Organisation    : ${metadata.tenantName}\n`;
    reportContent += `Tenant ID       : ${metadata.tenantId}\n`;
    reportContent += `Generated On    : ${metadata.generatedAt.toLocaleString()}\n`;
    reportContent += `Report Version  : ${this.REPORT_VERSION}\n`;
    reportContent += `Report Type     : ${metadata.reportType}\n\n`;
    
    // Executive Summary
    reportContent += `📈 EXECUTIVE SUMMARY\n`;
    reportContent += `${subDivider}\n`;
    
    if (data.pipedriveDisabled) {
      reportContent += `🔒 Pipedrive Status      : Disabled for this organization\n`;
      reportContent += `📊 Total Xero Projects   : ${data.onlyInXeroCount}\n`;
      reportContent += `✅ Report Type           : Xero Projects Analysis\n`;
      reportContent += `⚠️  Pipedrive Note       : ${data.pipedriveError || 'Integration disabled'}\n\n`;
    } else {
      reportContent += `Total Projects Analyzed  : ${data.matchedCount + data.onlyInPipedriveCount + data.onlyInXeroCount}\n`;
      reportContent += `✅ Matched Projects      : ${data.matchedCount}\n`;
      reportContent += `📤 Pipedrive Only        : ${data.onlyInPipedriveCount}\n`;
      reportContent += `📥 Xero Only             : ${data.onlyInXeroCount}\n`;
      reportContent += `🎯 Synchronization       : ${this.getSyncStatus(data)}\n`;
      reportContent += `⚠️  Action Required       : ${data.onlyInPipedriveCount > 0 || data.onlyInXeroCount > 0 ? 'Yes' : 'No'}\n\n`;
    }
    
    // Projects only in Pipedrive (skip if Pipedrive is disabled)
    if (!data.pipedriveDisabled && data.onlyInPipedriveCount > 0) {
      reportContent += `📤 PROJECTS ONLY IN PIPEDRIVE (${data.onlyInPipedriveCount})\n`;
      reportContent += `${subDivider}\n`;
      reportContent += `These projects exist in Pipedrive but not in Xero.\n`;
      reportContent += `Consider creating these projects in Xero for complete synchronization.\n\n`;
      
      data.projectsOnlyInPipedrive.forEach((project, index) => {
        reportContent += `${String(index + 1).padStart(3, ' ')}. ${project.name}\n`;
        reportContent += `     Key: ${project.key}\n`;
        if (project.status) reportContent += `     Status: ${project.status}\n`;
        reportContent += `\n`;
      });
    }
    
    // Projects in Xero (adjust title based on Pipedrive status)
    if (data.onlyInXeroCount > 0) {
      if (data.pipedriveDisabled) {
        reportContent += `📊 XERO PROJECTS (${data.onlyInXeroCount})\n`;
        reportContent += `${subDivider}\n`;
        reportContent += `Complete list of projects in your Xero organization.\n`;
        reportContent += `Pipedrive integration is disabled for this tenant.\n\n`;
      } else {
        reportContent += `📥 PROJECTS ONLY IN XERO (${data.onlyInXeroCount})\n`;
        reportContent += `${subDivider}\n`;
        reportContent += `These projects exist in Xero but not in Pipedrive.\n`;
        reportContent += `Consider reviewing project status in your CRM system.\n\n`;
      }
      
      data.projectsOnlyInXero.forEach((project, index) => {
        reportContent += `${String(index + 1).padStart(3, ' ')}. ${project.name}\n`;
        reportContent += `     Key: ${project.key}\n`;
        if (project.status) reportContent += `     Status: ${project.status}\n`;
        reportContent += `\n`;
      });
    }
    
    // Perfect sync message (only show if Pipedrive is enabled)
    if (!data.pipedriveDisabled && data.matchedCount > 0 && data.onlyInPipedriveCount === 0 && data.onlyInXeroCount === 0) {
      reportContent += `🎉 PERFECT SYNCHRONIZATION\n`;
      reportContent += `${subDivider}\n`;
      reportContent += `Congratulations! All projects are perfectly synchronized between\n`;
      reportContent += `Pipedrive and Xero. No action required.\n\n`;
    }
    
    // Pipedrive disabled message
    if (data.pipedriveDisabled) {
      reportContent += `🔒 PIPEDRIVE INTEGRATION STATUS\n`;
      reportContent += `${subDivider}\n`;
      reportContent += `Pipedrive integration is disabled for this organization.\n`;
      reportContent += `This report shows all projects currently in your Xero system.\n`;
      reportContent += `Contact your administrator if you need Pipedrive integration enabled.\n\n`;
    }
    
    // Technical details
    reportContent += `🔧 TECHNICAL DETAILS\n`;
    reportContent += `${subDivider}\n`;
    
    if (data.pipedriveDisabled) {
      reportContent += `Data Sources        : Xero (Accounting) Only\n`;
      reportContent += `Pipedrive Status    : Integration Disabled\n`;
      reportContent += `Analysis Type       : Xero Projects Inventory\n`;
      reportContent += `Total Projects      : ${data.onlyInXeroCount}\n`;
    } else {
      reportContent += `Data Sources        : Pipedrive (CRM) ↔ Xero (Accounting)\n`;
      reportContent += `Matching Algorithm  : Xero: code-name pattern (e.g., ED255007-vikingpassero)\n`;
      reportContent += `                      Pipedrive: ED projects use code-vessel (e.g., ED242263-ithaki)\n`;
      reportContent += `Match Accuracy      : ${((data.matchedCount / (data.matchedCount + data.onlyInPipedriveCount + data.onlyInXeroCount)) * 100).toFixed(1)}%\n`;
    }
    
    reportContent += `Processing Time     : ${new Date().toLocaleString()}\n\n`;
    
    reportContent += `${divider}\n`;
    reportContent += `End of Report - ${this.COMPANY_NAME}\n`;
    reportContent += `${divider}\n`;

    const blob = new Blob([reportContent], { type: 'text/plain;charset=utf-8' });
    saveAs(blob, `${fileName}.txt`);
  }

  /**
   * Calculates and returns human-readable synchronization status
   * @param {ProjectComparisonData} data - Project comparison data
   * @returns {string} Descriptive sync status with percentage
   */
  private static getSyncStatus(data: ProjectComparisonData): string {
    const total = data.matchedCount + data.onlyInPipedriveCount + data.onlyInXeroCount;
    if (total === 0) return 'No Data';
    
    const syncPercentage = (data.matchedCount / total) * 100;
    
    if (syncPercentage === 100) return 'Perfect Sync (100%)';
    if (syncPercentage >= 90) return `Excellent (${syncPercentage.toFixed(1)}%)`;
    if (syncPercentage >= 75) return `Good (${syncPercentage.toFixed(1)}%)`;
    if (syncPercentage >= 50) return `Moderate (${syncPercentage.toFixed(1)}%)`;
    return `Needs Attention (${syncPercentage.toFixed(1)}%)`;
  }
} 