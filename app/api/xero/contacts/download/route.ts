import { NextRequest, NextResponse } from 'next/server';
import { ensureValidToken } from '@/lib/ensureXeroToken';
import { trackXeroApiCall } from '@/lib/xeroApiTracker';
import { SmartRateLimit } from '@/lib/smartRateLimit';
import { auth } from '@/lib/auth';
import { AuditLogger } from '@/lib/auditLogger';
import * as XLSX from 'xlsx';

/**
 * GET /api/xero/contacts/download - Download Xero contacts as Excel file
 */
export async function GET(request: NextRequest) {
  // Initialize audit logger
  const session = await auth();
  const { access_token, effective_tenant_id, available_tenants } = await ensureValidToken();
  const selectedTenant = available_tenants?.find(t => t.tenantId === effective_tenant_id);
  const auditLogger = new AuditLogger(session, effective_tenant_id, selectedTenant?.tenantName);
  
  let downloadLogId: string | null = null;
  
  try {
    // Log the download attempt
    downloadLogId = await auditLogger.startAction('PROJECT_UPDATE', {
      action: 'DOWNLOAD_CONTACTS'
    });
    
    await SmartRateLimit.waitIfNeeded();
    
    const url = 'https://api.xero.com/api.xro/2.0/Contacts';
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${access_token}`,
        'Xero-tenant-id': effective_tenant_id,
        'Accept': 'application/json'
      }
    });

    await trackXeroApiCall(response.headers, effective_tenant_id);
    SmartRateLimit.updateFromHeaders(response.headers);

    if (!response.ok) {
      const errorText = await response.text();
      
      // Complete audit log with failure
      if (downloadLogId) {
        await auditLogger.completeAction(
          downloadLogId,
          'FAILURE',
          {
            httpStatus: response.status,
            error: errorText
          },
          `HTTP ${response.status}: ${errorText}`
        );
      }
      
      return NextResponse.json({ 
        error: `Failed to fetch contacts: ${response.status} ${errorText}` 
      }, { status: response.status });
    }

    const result = await response.json();
    const contacts = result.Contacts || [];

    // Create Excel workbook
    const workbook = XLSX.utils.book_new();
    
    // Create summary sheet
    const timestamp = new Date();
    const summaryData = [
      ['Xero Contacts Export'],
      [''],
      ['Export Information'],
      ['Generated By', session?.user?.name || session?.user?.email || 'System'],
      ['User Email', session?.user?.email || 'Unknown'],
      ['Organisation', selectedTenant?.tenantName || 'Unknown'],
      ['Tenant ID', effective_tenant_id],
      ['Generated On', timestamp.toLocaleString()],
      ['Total Contacts', contacts.length],
      [''],
      ['Export Summary'],
      ['Contact Count', contacts.length],
      ['Export Format', 'Microsoft Excel (.xlsx)'],
      ['Data Source', 'Xero Contacts API'],
      ['Last Updated', timestamp.toISOString()]
    ];

    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

    // Create contacts data sheet
    if (contacts.length > 0) {
      // Prepare contact data for Excel
      const contactsData = [
        [
          'Contact ID',
          'Name', 
          'Email',
          'Phone',
          'Contact Number',
          'Contact Status',
          'First Name',
          'Last Name',
          'Bank Account Details',
          'Tax Number',
          'Account Receivable',
          'Account Payable',
          'Addresses',
          'Is Supplier',
          'Is Customer',
          'Updated Date'
        ]
      ];

      contacts.forEach((contact: any) => {
        // Handle addresses
        const addresses = contact.Addresses ? 
          contact.Addresses.map((addr: any) => 
            `${addr.AddressType}: ${[addr.AddressLine1, addr.AddressLine2, addr.City, addr.Region, addr.PostalCode, addr.Country].filter(Boolean).join(', ')}`
          ).join(' | ') : 'N/A';

        contactsData.push([
          contact.ContactID || '',
          contact.Name || '',
          contact.EmailAddress || '',
          contact.ContactPersons?.[0]?.PhoneNumbers?.[0]?.PhoneNumber || '',
          contact.ContactNumber || '',
          contact.ContactStatus || '',
          contact.FirstName || '',
          contact.LastName || '',
          contact.BankAccountDetails ? 'Present' : 'None',
          contact.TaxNumber || '',
          contact.AccountReceivableTaxType || '',
          contact.AccountPayableTaxType || '',
          addresses,
          contact.IsSupplier ? 'Yes' : 'No',
          contact.IsCustomer ? 'Yes' : 'No',
          contact.UpdatedDateUTC ? new Date(contact.UpdatedDateUTC).toLocaleDateString() : ''
        ]);
      });

      const contactsSheet = XLSX.utils.aoa_to_sheet(contactsData);
      XLSX.utils.book_append_sheet(workbook, contactsSheet, 'Contacts');
    }

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'buffer' });
    
    // Generate filename with timestamp
    const fileTimestamp = timestamp.toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `xero-contacts-export-${fileTimestamp}.xlsx`;

    // Complete audit log with success
    if (downloadLogId) {
      await auditLogger.completeAction(
        downloadLogId,
        'SUCCESS',
        {
          contactCount: contacts.length,
          filename: filename
        }
      );
    }

    // Return Excel file
    return new NextResponse(excelBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Cache-Control': 'no-cache',
        'Content-Length': excelBuffer.length.toString()
      },
    });
    
  } catch (error: any) {
    console.error('[Contacts Download API] Error:', error);
    
    // Complete audit log with failure
    if (downloadLogId) {
      await auditLogger.completeAction(
        downloadLogId,
        'FAILURE',
        {
          error: error.message
        },
        error.message
      );
    }
    
    return NextResponse.json({ 
      error: error.message || 'An error occurred while downloading contacts' 
    }, { status: 500 });
  }
} 